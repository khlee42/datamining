---
title: "Data wrangling <br> `r emo::ji('wrench')`"
author: "Kyunghee Lee"
output:
  xaringan::moon_reader:
    css: "../slides.css"
    lib_dir: libs
    nature:
      ratio: "16:9"
      highlightLines: true
      highlightStyle: solarized-light
      countIncrementalSlides: false
---

```{r child = "../setup.Rmd"}
```

```{r packages, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(emo)
library(dsbox)
```

class: center, middle

# Grammar of data wrangling

---

## A grammar of data wrangling...

... based on the concepts of functions as verbs that **manipulate** data frames

.pull-left[
```{r dplyr-part-of-tidyverse, echo=FALSE, out.width="80%", fig.align = "center", caption = "dplyr is part of the tidyverse"}
knitr::include_graphics("img/dplyr-part-of-tidyverse.png")
```
]
.pull-right[
.midi[
- `select`: pick columns by name
- `arrange`: reorder rows
- `slice`: pick rows using index(es)
- `filter`: pick rows matching criteria
- `distinct`: filter for unique rows
- `mutate`: add new variables
- `summarise`: reduce variables to values
- `group_by`: for grouped operations
- ... (many more)
]
]

---

## Data: Hotel bookings

- Data from two hotels: one resort and one city hotel
- Observations: Each row represents a hotel booking
- Goal for original data collection: Development of prediction models to classify a hotel booking's likelihood to be cancelled ([Antonia et al., 2019](https://www.sciencedirect.com/science/article/pii/S2352340918315191#bib5))

```{r echo=FALSE, message=FALSE}
hotels <- read_csv("data/hotels.csv")
```

---

## First look: Variables

```{r message=FALSE}
names(hotels)
```

---

## Second look: Overview

.xxsmall[
```{r}
glimpse(hotels)
```
]

---

## Select a single column

View only the `lead_time` type (number of days between booking and arrival date):

--
.pull-left[
.small[
```{r}
select(.data = hotels, variable = lead_time)
```
]
]

--
.pull-right[
.small[
- Start with the function (a verb): `select()`
- First argument is `.data` (the data frame we're working with) = `hotels`
- Second argument is variable we want to select: `lead_time`
- The result is a data frame with 119,300 and 1 column: --dplyr functions always 
expect a data frame and always yield a data frame.
]
]

---

.tip[
You can skip the argument name for the first two arguments of a function.
]

.pull-left[
.small[
```{r}
select(.data = hotels, variable = lead_time)
```
]
]
.pull-right[
.small[
```{r}
select(hotels, lead_time)
```
]
]

---

## Select multiple columns


View only the `hotel` type and `lead_time`:

--

.pull-left[
```{r}
select(hotels, hotel, lead_time)
```
]
--
.pull-right[
.discussion[
What if we wanted to select these columns, and then arrange the data in descending order of lead time?
]
]

---

## Data wrangling, step-by-step

.pull-left[
Select:
```{r}
hotels %>%
  select(hotel, lead_time)
```
]

--
.pull-right[
Select, then arrange:
```{r}
hotels %>%
  select(hotel, lead_time) %>%
  arrange(desc(lead_time))
```
]

---

## What is a pipe %>%?

In programming, a pipe is a technique for passing information from one process to another.

--

.pull-left[
- Start with the data frame `hotels`, and pass it to the `select()` function,
]
.pull-right[
.small[
```{r}
hotels %>% #<<
  select(hotel, lead_time) %>%
  arrange(desc(lead_time))
```
]
]

---

## What is a pipe %>%?

In programming, a pipe is a technique for passing information from one process to another.

.pull-left[
- Start with the data frame `hotels`, and pass it to the `select()` function,
- then we select the variables `hotel` and `lead_time`,
]
.pull-right[
.small[
```{r}
hotels %>%
  select(hotel, lead_time) %>% #<<
  arrange(desc(lead_time))
```
]
]

---

## What is a pipe %>%?

In programming, a pipe is a technique for passing information from one process to another.

.pull-left[
- Start with the data frame `hotels`, and pass it to the `select()` function,
- then we select the variables `hotel` and `lead_time`,
- and then we arrange the data frame by `lead_time` in descending order.
]
.pull-right[
.small[
```{r}
hotels %>%
  select(hotel, lead_time) %>% 
  arrange(desc(lead_time)) #<<
```
]
]

---

## How does a pipe work?

- You can think about the following sequence of actions - find key, 
unlock car, start car, drive to work, park.

--
- Expressed as a set of nested functions in R pseudocode this would look like:
```{r eval=FALSE}
park(drive(start_car(find("keys")), to = "work"))
```

--
- Writing it out using pipes give it a more natural (and easier to read) 
structure:
```{r eval=FALSE}
find("keys") %>%
  start_car() %>%
  drive(to = "work") %>%
  park()
```

---

## What about other arguments?

Use the dot to

- send results to a function argument other than first one or 
- use the previous result for multiple arguments

```{r fig.height=1.8, fig.width = 3.75}
hotels %>%
  filter(hotel == "Resort Hotel") %>%
  lm(adr ~ lead_time, data = .) #<<
```

---

## A note on piping and layering

- The `%>%` operator in **dplyr** functions is called the pipe operator. This means you "pipe" the output of the previous line of code as the first input of the next line of code.

- The `+` operator in **ggplot2** functions is used for "layering". This means you create the plot in layers, separated by `+`.

---

## dplyr "pipe"

.midi[
`r emo::ji("x")`

```{r error=TRUE}
hotels +
  select(hotel, lead_time)
```

`r emo::ji("white_check_mark")`

```{r eval=FALSE}
hotels %>%
  select(hotel, lead_time)
```

```{r echo=FALSE}
hotels %>%
  select(hotel, lead_time) %>%
  print(n = 6)
```
]

---

## ggplot2 "layering"

.midi[
`r emo::ji("x")`

```{r error=TRUE}
ggplot(hotels, aes(x = hotel, fill = deposit_type)) %>%
  geom_bar()
```

`r emo::ji("white_check_mark")`

```{r fig.width=10, fig.height=2, dpi=300}
ggplot(hotels, aes(x = hotel, fill = deposit_type)) +
  geom_bar()
```
]

---

## Code styling

Many of the styling principles are consistent across `%>%` and `+`:

- always a space before
- always a line break after (for pipelines with more than 2 lines)

`r emo::ji("x")`

```{r eval=FALSE}
ggplot(hotels,aes(x=hotel,y=deposit_type))+geom_bar()
```

`r emo::ji("white_check_mark")`

```{r eval=FALSE}
ggplot(hotels, aes(x = hotel, y = deposit_type)) + 
  geom_bar()
```

---
## Code styling

`r emo::ji("x")` 

```{r eval=FALSE}
find("keys") %>% start_car() %>% drive(to = "work") %>% park()
```

`r emo::ji("white_check_mark")`
```{r eval=FALSE}
find("keys") %>%
  start_car() %>%
  drive(to = "work") %>%
  park()
```

---

class: center, middle

# Working with a single data frame

---

class: center, middle

# Manipulate columns

---

## `select` to keep variables

```{r}
hotels %>%
  select(hotel, lead_time) #<<
```

---

## `select` to exclude variables

.small[
```{r}
hotels %>%
  select(-agent) #<<
```
]

---

## `select` variables with certain characteristics

```{r}
hotels %>%
  select(starts_with("arrival")) #<<
```

---

## `select` variables with certain characteristics

```{r}
hotels %>%
  select(ends_with("type")) #<<
```

---

## Select helpers

- `starts_with()`: Starts with a prefix
- `ends_with()`: Ends with a suffix
- `contains()`: Contains a literal string
- `num_range()`: Matches a numerical range like x01, x02, x03
- `one_of()`: Matches variable names in a character vector
- `everything()`: Matches all variables
- `last_col()`: Select last variable, possibly with an offset
- `matches()`: Matches a regular expression (a sequence of symbols/characters expressing a string/pattern to be searched for within text)

.footnote[
See help for any of these functions for more info, e.g. `?everything`.
]

---

## `mutate` to add a new variable

```{r}
hotels %>%
  mutate(little_ones = children + babies) %>% #<<
  select(children, babies, little_ones) %>%
  arrange(desc(little_ones))
```

---

## `arrange` in ascending / descending order

.pull-left[
```{r}
hotels %>%
  select(adults, children, babies) %>%
  arrange(babies) #<<
```
]
.pull-right[
```{r}
hotels %>%
  select(adults, children, babies) %>%
  arrange(desc(babies)) #<<
```
]

---

class: center, middle

# Manipulate rows

---

## `slice` for certain row numbers

.midi[
```{r}
# first five
hotels %>%
  slice(1:5) #<<
```
]

---

.tip[
In R, you can use the `#` for adding comments to your code. 
Any text following `#` will be printed as is, and won't be run as R code.
This is useful for leaving comments in your code and for temporarily disabling 
certain lines of code while debugging.
]

.small[
```{r}
hotels %>%
  # slice the first five rows  # this line is a comment
  #select(hotel) %>%           # this one doesn't run
  slice(1:5)                   # this line runs
```
]

---

## `slice` for certain row numbers

.midi[
```{r}
# last five
last_row <- nrow(hotels)         # nrow() gives the number of rows in a data frame
hotels %>%
  slice((last_row - 4):last_row) #<<
```
]

---

## `filter` to select a subset of rows

.midi[
```{r}
# bookings in City Hotels
hotels %>%
  filter(hotel == "City Hotel") #<<
````
]

---

## `filter` for many conditions at once

```{r}
hotels %>%
  filter( 
    adults == 0,     #<<
    children >= 1    #<<
    ) %>% 
  select(adults, babies, children)
```

---

## `filter` for more complex conditions

```{r}
# bookings with no adults and some children or babies in the room
hotels %>%
  filter( 
    adults == 0,     
    children >= 1 | babies >= 1     # | means or  #<<
    ) %>%
  select(adults, babies, children)
```

---

## Logical operators in R

<br>

operator    | definition                   || operator     | definition
------------|------------------------------||--------------|----------------
`<`         | less than                    || `x & y`      | `x` AND `y`
`<=`        |	less than or equal to        || `x`&nbsp;&#124;&nbsp;`y`   | `x` OR `y` 
            |                              || `!x`         | not `x`
`>`         | greater than                 || `is.na(x)`   | test if `x` is `NA`
`>=`        |	greater than or equal to     || `!is.na(x)`  | test if `x` is not `NA`
`==`        |	exactly equal to             || `x %in% y`   | test if `x` is in `y`
`!=`        |	not equal to                 || `!(x %in% y)`| test if `x` is not in `y`

[Searching Effectively Boolean Operators](https://www.youtube.com/watch?v=eV2s0Yc8RCc)

---

## `distinct` to filter for unique rows

.small[
.pull-left[
```{r}
hotels %>% 
  select(market_segment)
```
]
]

--

.small[
.pull-right[
```{r}
hotels %>% 
  distinct(market_segment)
```
]
]

---


```{r include=FALSE}
options(dplyr.print_max = 20)
```

## `distinct` to filter for unique rows

... and `arrange` to order alphabetically

.small[
.pull-left[
```{r}
hotels %>% 
  distinct(market_segment) %>% #<<
  arrange(market_segment)
```
]
.pull-right[
```{r}
hotels %>% 
  distinct(hotel, market_segment) %>% #<<
  arrange(hotel, market_segment)
```
]
]

---

class: center, middle

# Explore data

---

## `count` to create frequency tables

.pull-left[
```{r}
# alphabetical order by default
hotels %>%
  count(market_segment) #<<
```
]
--
.pull-right[
```{r}
# descending frequency order
hotels %>%
  count(market_segment, sort = TRUE) #<<
```
]

---

## `count` and `arrange`

.pull-left[
```{r}
# ascending frequency order
hotels %>%
  count(market_segment) %>%
  arrange(n) #<<
```
]
.pull-right[
```{r}
# descending frequency order
# just like adding sort = TRUE
hotels %>%
  count(market_segment) %>%
  arrange(desc(n)) #<<
```
]

---

## `count` for multiple variables

```{r}
hotels %>%
  count(hotel, market_segment) #<<
```

---

.question[For each hotel, select the booking records that have more than one little one]

--

.small[
.pull-left[
```{r}
# Resort Hotel
hotels %>%
  mutate(little_ones = children + babies) %>%
  filter(
    little_ones >= 1,
    hotel == "Resort Hotel"
    ) %>%
  select(hotel, little_ones)
```
]
]

--

.small[
.pull-right[
```{r}
# City Hotel
hotels %>%
  mutate(little_ones = children + babies) %>%
  filter(
    little_ones > 1,
    hotel == "City Hotel"
    )  %>%
  select(hotel, little_ones)
```
]
]

---

.discussion[
What is happening in the following chunk?
]

.midi[
```{r}
hotels %>%
  mutate(little_ones = children + babies) %>%
  count(hotel, little_ones) %>%
  mutate(prop = n / sum(n))
```
]

---

## `summarise` for summary stats
.midi[
```{r}
# mean average daily rate for all bookings
hotels %>%
  summarise(mean(adr)) #<<
```
```{r}
# mean average daily rate for all bookings
hotels %>%
  summarise(mean_adr = mean(adr)) #<<
```
]

---

## Multiple summary statistics

`summarise` can be used for multiple summary statistics as well

```{r}
hotels %>%
  summarise(
    min_adr = min(adr),
    mean_adr = mean(adr),
    median_adr = median(adr),
    max_adr = max(adr)
    )
```
`?summarise` for help

---

## Save result

.small[
.pull-left[
```{r}
booking_with_littleone <- hotels %>%
  mutate(little_ones = children + babies) %>%
  filter(
    little_ones >= 1,
    ) %>%
  select(hotel, little_ones)
booking_with_littleone
```
]
.pull-right[
```{r}
max <- booking_with_littleone %>% 
  summarise(max_littleones = max(little_ones))
max
```
]
]
---

## `group_by` for grouped operations

```{r}
# mean average daily rate for all booking at city and resort hotels
hotels %>%
  group_by(hotel) %>% #<<
  summarise(mean_adr = mean(adr))
```

---

## `group_by` for grouped operations

```{r}
# mean average daily rate for all booking at city and resort hotels
hotels %>%
  group_by(customer_type) %>% #<<
  summarise(mean_adr = mean(adr))
```

---


## Wrap-up

- dplyr and pipe
- Manipulate columns
- Manipulate rows
- Explore data


